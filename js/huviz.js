// Generated by CoffeeScript 1.6.3
(function() {
  var Huviz;

  Huviz = (function() {
    var BLANK_HACK, COARSE, DEBUG, DUMP, FOAF_Group, FOAF_name, G, MODERATE, RDF_Type, RDF_object, TEMP, UNDEFINED, add_link, add_node_ghosts, add_to, add_to_array, add_webgl_line, await_the_GreenTurtle, binary_search_on, blank_screen, calc_node_radius, canvas, canvas_show_text, change_sort_order, charge, choose, chosen_set, clear_canvas, cmp_on_id, cmp_on_name, color_by_type, ctx, cursor, cx, cy, default_node_radius_policy, discard, discard_center, discard_found_nodes, discard_radius, discarded_set, dist_lt, distance, do_tests, drag_dist_threshold, dragging, draw_circle, draw_circle_around_focused, draw_discard_dropzone, draw_discards, draw_disconnect_dropzone, draw_dropzones, draw_edges, draw_labels, draw_lariat, draw_lariat_labels_rotated, draw_line, draw_nodes, draw_nodes_in_set, dump_details, dump_locations, edge_controller, ensure_predicate, fetchAndShow, fill, find_focused_node, find_links_from_node, find_links_to_node, fisheye, fisheye_radius, fisheye_zoom, focus_radius, focused_node, force, get_charge, get_node_by_id, get_or_make_node, get_window_height, get_window_width, graph_radius, graphed_set, gravity, has_predicate_value, has_type, height, hide_all_links, hide_found_links, hide_links_from_node, hide_links_to_node, hide_node_links, hpad, id2n, id2u, ids_to_show, in_discard_dropzone, in_disconnect_dropzone, init_node_radius_policy, init_webgl, isArray, is_a_main_node, is_node_to_always_show, label_all_graphed_nodes, label_show_range, lariat, lariat_center, last_mouse_pos, last_status, link, link_distance, links_set, little_dot, load_file, make_edge, make_links, make_nodes, mouse_receiver, mousedown, mousedown_point, mousemove, mouseup, move_node_to_point, names_in_edges, node, node_radius_policies, node_radius_policy, nodes, nodes_pinnable, parseAndShow, pnt2str, position_nodes, predicates, remove_from, remove_from_array, remove_ghosts, remove_link, reset_graph, restart, restore_graph_state, roughSizeOfObject, run_force_after_mouseup_msec, search_regex, set_node_radius_policy, set_search_regex, set_status, should_show_label, showGraph, show_and_hide_links_from_node, show_found_links, show_last_mouse_pos, show_line, show_link, show_links_from_node, show_links_to_node, show_node_links, show_pos, start_with_http, svg, svg_restart, tick, toggle_display_tech, toggle_label_display, toggle_links, unchoose, undiscard, unlink, unlinked_set, updateWindow, update_discard_zone, update_flags, update_graph_radius, update_history, update_lariat_zone, update_searchterm, update_state, update_status, use_canvas, use_svg, use_webgl, verbose, verbosity, viscanvas, wait_for_GreenTurtle, webgl_restart, width, wpad;

    function Huviz() {}

    use_canvas = true;

    use_svg = false;

    use_webgl = false;

    nodes = void 0;

    links_set = void 0;

    node = void 0;

    link = void 0;

    chosen_set = void 0;

    discarded_set = void 0;

    graphed_set = void 0;

    unlinked_set = void 0;

    focused_node = void 0;

    lariat = void 0;

    label_all_graphed_nodes = false;

    verbose = true;

    verbosity = 0;

    TEMP = 5;

    COARSE = 10;

    MODERATE = 20;

    DEBUG = 40;

    DUMP = false;

    node_radius_policy = void 0;

    draw_circle_around_focused = false;

    draw_lariat_labels_rotated = true;

    run_force_after_mouseup_msec = 2000;

    nodes_pinnable = false;

    BLANK_HACK = false;

    wpad = void 0;

    hpad = 10;

    width = void 0;

    height = 0;

    cx = 0;

    cy = 0;

    link_distance = 20;

    charge = -30;

    gravity = 0.3;

    label_show_range = link_distance * 1.1;

    graph_radius = 100;

    discard_radius = 200;

    fisheye_radius = label_show_range * 5;

    focus_radius = label_show_range;

    drag_dist_threshold = 5;

    dragging = false;

    last_status = void 0;

    G = {};

    start_with_http = new RegExp("http", "ig");

    ids_to_show = start_with_http;

    id2n = {};

    id2u = {};

    search_regex = new RegExp("^$", "ig");

    little_dot = .5;

    fisheye_zoom = 2.8;

    mousedown_point = [cx, cy];

    discard_center = [cx, cy];

    lariat_center = [cx, cy];

    last_mouse_pos = [0, 0];

    predicates = {
      name: 'edges',
      children: []
    };

    ensure_predicate = function(p_name) {
      var pobj, _i, _len, _ref;
      _ref = predicates.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pobj = _ref[_i];
        if (pobj.name === p_name) {
          break;
        }
      }
      return predicates.children.push({
        name: p_name,
        children: []
      });
    };

    change_sort_order = function(array, cmp) {
      array.__current_sort_order = cmp;
      return array.sort(array.__current_sort_order);
    };

    isArray = function(thing) {
      return Object.prototype.toString.call(thing) === "[object Array]";
    };

    cmp_on_name = function(a, b) {
      if (a.name === b.name) {
        return 0;
      }
      if (a.name < b.name) {
        return -1;
      }
      return 1;
    };

    cmp_on_id = function(a, b) {
      if (a.id === b.id) {
        return 0;
      }
      if (a.id < b.id) {
        return -1;
      }
      return 1;
    };

    binary_search_on = function(sorted_array, sought, cmp, ret_ins_idx) {
      var bot, c, mid, seeking, top;
      cmp = cmp || sorted_array.__current_sort_order || cmp_on_id;
      ret_ins_idx = ret_ins_idx || false;
      seeking = true;
      if (sorted_array.length < 1) {
        if (ret_ins_idx) {
          return {
            idx: 0
          };
        }
        return -1;
      }
      mid = void 0;
      bot = 0;
      top = sorted_array.length;
      while (seeking) {
        mid = bot + Math.floor((top - bot) / 2);
        c = cmp(sorted_array[mid], sought);
        if (c === 0) {
          return mid;
        }
        if (c < 0) {
          bot = mid + 1;
        } else {
          top = mid;
        }
        if (bot === top) {
          if (ret_ins_idx) {
            return {
              idx: bot
            };
          }
          return -1;
        }
      }
    };

    do_tests = function(verbose) {
      var a, a_d, b, c, d, even, expect, ints, n, stuff;
      expect = function(stmt, want) {
        var got;
        got = eval(stmt);
        if (verbose) {
          console.log(stmt, "==>", got);
        }
        if (got !== want) {
          throw stmt + " returned " + got + " expected " + want;
        }
      };
      verbose = verbose || false;
      n = function(a, b) {
        if (a === b) {
          return 0;
        }
        if (a < b) {
          return -1;
        }
        return 1;
      };
      a = {
        id: 1
      };
      b = {
        id: 2
      };
      c = {
        id: 0
      };
      d = {
        id: 3
      };
      stuff = [a, b];
      a_d = [a, d];
      ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10];
      even = [0, 2, 4, 6, 8, 10];
      expect("cmp_on_id(a,a)", 0);
      expect("cmp_on_id(a,b)", -1);
      expect("cmp_on_id(b,a)", 1);
      expect("binary_search_on(ints,0,n)", 0);
      expect("binary_search_on(ints,4,n)", 4);
      expect("binary_search_on(ints,8,n)", 8);
      expect("binary_search_on(ints,9,n)", -1);
      expect("binary_search_on(ints,9,n,true).idx", 9);
      expect("binary_search_on(ints,-3,n)", -1);
      expect("binary_search_on(even,1,n,true).idx", 1);
      expect("binary_search_on(even,3,n,true).idx", 2);
      expect("binary_search_on(even,5,n,true).idx", 3);
      expect("binary_search_on(even,7,n,true).idx", 4);
      expect("binary_search_on(even,9,n,true).idx", 5);
      expect("binary_search_on(even,9,n)", -1);
      expect("binary_search_on(even,11,n,true).idx", 6);
      expect("binary_search_on(stuff,a)", 0);
      expect("binary_search_on(stuff,b)", 1);
      expect("binary_search_on(stuff,c)", -1);
      expect("binary_search_on(stuff,d)", -1);
      expect("binary_search_on(a_d,c,cmp_on_id)", -1);
      expect("binary_search_on(a_d,c,cmp_on_id,true).idx", 0);
      expect("binary_search_on(a_d,b,cmp_on_id,true).idx", 1);
      expect("add_to_array(b,a_d)", 1);
      expect("binary_search_on(a_d,a,cmp_on_id)", 0);
      expect("binary_search_on(a_d,b,cmp_on_id)", 1);
      expect("binary_search_on(a_d,d,cmp_on_id)", 2);
      return expect("add_to_array(c,a_d)", 0);
    };

    roughSizeOfObject = function(object) {
      var bytes, i, objectList, stack, value;
      objectList = [];
      stack = [object];
      bytes = 0;
      while (stack.length) {
        value = stack.pop();
        if (typeof value === "boolean") {
          bytes += 4;
        } else if (typeof value === "string") {
          bytes += value.length * 2;
        } else if (typeof value === "number") {
          bytes += 8;
        } else if (typeof value === "object" && objectList.indexOf(value) === -1) {
          objectList.push(value);
          for (i in value) {
            stack.push(value[i]);
          }
        }
      }
      return bytes;
    };

    color_by_type = function(d) {
      if (has_type(d.s, FOAF_Group)) {
        return "green";
      } else if (d.s.id[0] === "_") {
        return "red";
      } else {
        return "blue";
      }
    };

    distance = function(p1, p2) {
      var x, y;
      x = (p1.x || p1[0]) - (p2.x || p2[0]);
      y = (p1.y || p1[1]) - (p2.y || p2[1]);
      return Math.sqrt(x * x + y * y);
    };

    move_node_to_point = function(node, point) {
      node.x = point[0];
      return node.y = point[1];
    };

    mousemove = function() {
      last_mouse_pos = d3.mouse(this);
      if (!dragging && mousedown_point && focused_node && distance(last_mouse_pos, mousedown_point) > drag_dist_threshold && focused_node.state === graphed_set) {
        dragging = focused_node;
      }
      if (dragging) {
        force.resume();
        move_node_to_point(dragging, last_mouse_pos);
      }
      cursor.attr("transform", "translate(" + last_mouse_pos + ")");
      return tick();
    };

    mousedown = function() {
      mousedown_point = d3.mouse(this);
      return last_mouse_pos = mousedown_point;
    };

    mouseup = function() {
      var clickee, point;
      mousedown_point = false;
      point = d3.mouse(this);
      if (dragging) {
        move_node_to_point(dragging, point);
        if (in_discard_dropzone(dragging)) {
          console.log("discarding", dragging.name);
          discard(dragging);
        } else {
          if (nodes_pinnable) {
            dragging.fixed = true;
          }
        }
        if (in_disconnect_dropzone(dragging)) {
          console.log("disconnect", dragging.name);
          unchoose(dragging);
        }
        dragging = false;
        return;
      }
      if (focused_node && focused_node.fixed && focused_node.state === graphed_set ? nodes_pinnable : void 0) {
        focused_node.fixed = false;
      }
      if (distance(point, mousedown_point) > drag_dist_threshold) {
        return;
      }
      if (focused_node) {
        clickee = focused_node;
        if (clickee.state !== graphed_set) {
          choose(clickee);
        } else if (clickee.showing_links === "all") {
          unchoose(clickee);
        } else {
          choose(clickee);
        }
        force.links(links_set);
        return restart();
      }
    };

    updateWindow = function() {
      get_window_width();
      get_window_height();
      update_graph_radius();
      update_discard_zone();
      update_lariat_zone();
      if (svg) {
        svg.attr("width", width).attr("height", height);
      }
      if (canvas) {
        canvas.width = width;
        canvas.height = height;
      }
      force.size([width, height]);
      return restart();
    };

    get_charge = function(d) {
      if (!graphed_set.has(d)) {
        return 0;
      }
      return charge;
    };

    init_webgl = function() {
      init();
      return animate();
    };

    draw_circle = function(cx, cy, radius, strclr, filclr) {
      if (strclr) {
        ctx.strokeStyle = strclr || "blue";
      }
      if (filclr) {
        ctx.fillStyle = filclr || "blue";
      }
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2, true);
      ctx.closePath();
      if (strclr) {
        ctx.stroke();
      }
      if (filclr) {
        return ctx.fill();
      }
    };

    draw_line = function(x1, y1, x2, y2, clr) {
      ctx.strokeStyle = clr || red;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.closePath();
      return ctx.stroke();
    };

    draw_disconnect_dropzone = function() {
      ctx.save();
      ctx.lineWidth = graph_radius * 0.1;
      draw_circle(lariat_center[0], lariat_center[1], graph_radius, "lightgreen");
      return ctx.restore();
    };

    draw_discard_dropzone = function() {
      ctx.save();
      ctx.lineWidth = discard_radius * 0.1;
      draw_circle(discard_center[0], discard_center[1], discard_radius, "", "salmon");
      return ctx.restore();
    };

    draw_dropzones = function() {
      if (dragging) {
        draw_disconnect_dropzone();
        return draw_discard_dropzone();
      }
    };

    in_disconnect_dropzone = function(node) {
      var dist;
      dist = distance(node, lariat_center);
      return graph_radius * 0.9 < dist && graph_radius * 1.1 > dist;
    };

    in_discard_dropzone = function(node) {
      var dist;
      dist = distance(node, discard_center);
      return discard_radius * 1.1 > dist;
    };

    reset_graph = function() {
      var hidden_set;
      id2n = {};
      nodes = [];
      change_sort_order(nodes, cmp_on_id);
      chosen_set = SortedSet().named("chosen").isFlag().sort_on("id");
      unlinked_set = SortedSet().sort_on("name").named("unlinked").isState();
      discarded_set = SortedSet().sort_on("name").named("discarded").isState();
      hidden_set = SortedSet().sort_on("id").named("hidden").isState();
      graphed_set = SortedSet().sort_on("id").named("graphed").isState();
      links_set = SortedSet().named("shown").isFlag().sort_on("id");
      force.nodes(nodes);
      d3.select(".link").remove();
      d3.select(".node").remove();
      d3.select(".lariat").remove();
      node = svg.selectAll(".node");
      link = svg.selectAll(".link");
      lariat = svg.selectAll(".lariat");
      link = link.data(links_set);
      link.exit().remove();
      node = node.data(nodes);
      node.exit().remove();
      return force.start();
    };

    dist_lt = function(mouse, d, thresh) {
      var x, y;
      x = mouse[0] - d.x;
      y = mouse[1] - d.y;
      return Math.sqrt(x * x + y * y) < thresh;
    };

    set_node_radius_policy = function(evt) {
      var f;
      f = $("select#node_radius_policy option:selected").val();
      if (!f) {
        return;
      }
      if (typeof f === typeof "str") {
        return node_radius_policy = node_radius_policies[f];
      } else if (typeof f === typeof set_node_radius_policy) {
        return node_radius_policy = f;
      } else {
        return console.log("f =", f);
      }
    };

    init_node_radius_policy = function() {
      var policy_box, policy_name, policy_picker, _results;
      policy_box = d3.select("#huvis_controls").append("div", "node_radius_policy_box");
      policy_picker = policy_box.append("select", "node_radius_policy");
      policy_picker.on("change", set_node_radius_policy);
      _results = [];
      for (policy_name in node_radius_policies) {
        _results.push(policy_picker.append("option").attr("value", policy_name).text(policy_name));
      }
      return _results;
    };

    calc_node_radius = function(d) {
      return node_radius_policy(d);
    };

    names_in_edges = function(set) {
      var out;
      out = [];
      set.forEach(function(itm, i) {
        return out.push(itm.source.name + " ---> " + itm.target.name);
      });
      return out;
    };

    dump_details = function(node) {
      return;
      console.log("=================================================");
      console.log(node.name);
      console.log("  x,y:", node.x, node.y);
      try {
        console.log("  state:", node.state.state_name, node.state);
      } catch (_error) {}
      console.log("  chosen:", node.chosen);
      console.log("  fisheye:", node.fisheye);
      console.log("  fixed:", node.fixed);
      console.log("  links_shown:", node.links_shown.length, names_in_edges(node.links_shown));
      console.log("  links_to:", node.links_to.length, names_in_edges(node.links_to));
      console.log("  links_from:", node.links_from.length, names_in_edges(node.links_from));
      console.log("  showing_links:", node.showing_links);
      return console.log("  in_sets:", node.in_sets);
    };

    find_focused_node = function() {
      var closest, closest_point, focus_threshold, msg, new_focused_idx, new_focused_node, status, svg_node;
      if (dragging) {
        return;
      }
      new_focused_node = void 0;
      new_focused_idx = void 0;
      focus_threshold = focus_radius * 3;
      closest = width;
      closest_point = void 0;
      nodes.forEach(function(d, i) {
        var dist;
        dist = distance(d.fisheye || d, last_mouse_pos);
        if (dist < closest) {
          closest = dist;
          closest_point = d.fisheye || d;
        }
        if (dist <= focus_threshold) {
          new_focused_node = d;
          focus_threshold = dist;
          return new_focused_idx = i;
        }
      });
      if (draw_circle_around_focused) {
        draw_circle(closest_point.x, closest_point.y, focus_radius, "red");
      }
      msg = focus_threshold + " <> " + closest;
      status = $("#status");
      if (focused_node !== new_focused_node) {
        if (focused_node) {
          if (use_svg) {
            d3.select(".focused_node").classed("focused_node", false);
          }
          focused_node.focused_node = false;
        }
        if (new_focused_node) {
          new_focused_node.focused_node = true;
          if (use_svg) {
            svg_node = node[0][new_focused_idx];
            d3.select(svg_node).classed("focused_node", true);
          }
          dump_details(new_focused_node);
        }
      }
      return focused_node = new_focused_node;
    };

    draw_edges = function() {
      var dx, dy;
      if (use_svg) {
        link.attr("x1", function(d) {
          return d.source.fisheye.x;
        }).attr("y1", function(d) {
          return d.source.fisheye.y;
        }).attr("x2", function(d) {
          return d.target.fisheye.x;
        }).attr("y2", function(d) {
          return d.target.fisheye.y;
        });
      }
      if (use_canvas) {
        links_set.forEach(function(e, i) {
          return draw_line(e.source.fisheye.x, e.source.fisheye.y, e.target.fisheye.x, e.target.fisheye.y, e.color);
        });
      }
      if (use_webgl) {
        dx = width * xmult;
        dy = height * ymult;
        dx = -1 * cx;
        dy = -1 * cy;
        links_set.forEach(function(e) {
          var l;
          if (!e.target.fisheye) {
            e.target.fisheye = fisheye(e.target);
          }
          if (!e.gl) {
            add_webgl_line(e);
          }
          l = e.gl;
          mv_line(l, e.source.fisheye.x, e.source.fisheye.y, e.target.fisheye.x, e.target.fisheye.y);
          return dump_line(l);
        });
      }
      if (use_webgl && false) {
        return links_set.forEach(function(e, i) {
          var v;
          if (!e.gl) {
            return;
          }
          v = e.gl.geometry.vertices;
          v[0].x = e.source.fisheye.x;
          v[0].y = e.source.fisheye.y;
          v[1].x = e.target.fisheye.x;
          return v[1].y = e.target.fisheye.y;
        });
      }
    };

    position_nodes = function() {
      var n_nodes;
      n_nodes = nodes.length || 0;
      return nodes.forEach(function(node, i) {
        if (dragging === node) {
          move_node_to_point(node, last_mouse_pos);
        }
        if (!graphed_set.has(node)) {
          return;
        }
        return node.fisheye = fisheye(node);
      });
    };

    draw_nodes_in_set = function(set, radius, center) {
      var num;
      cx = center[0];
      cy = center[1];
      num = set.length;
      return set.forEach(function(node, i) {
        var rad;
        rad = 2 * Math.PI * i / num;
        node.rad = rad;
        node.x = cx + Math.sin(rad) * radius;
        node.y = cy + Math.cos(rad) * radius;
        node.fisheye = fisheye(node);
        if (use_canvas) {
          draw_circle(node.fisheye.x, node.fisheye.y, calc_node_radius(node), node.color || "yellow", node.color || "black");
        }
        if (use_webgl) {
          return mv_node(node.gl, node.fisheye.x, node.fisheye.y);
        }
      });
    };

    draw_discards = function() {
      return draw_nodes_in_set(discarded_set, discard_radius, discard_center);
    };

    draw_lariat = function() {
      return draw_nodes_in_set(unlinked_set, graph_radius, lariat_center);
    };

    draw_nodes = function() {
      if (use_svg) {
        node.attr("transform", function(d, i) {
          return "translate(" + d.fisheye.x + "," + d.fisheye.y + ")";
        }).attr("r", calc_node_radius);
      }
      if (use_canvas || use_webgl) {
        return nodes.forEach(function(d, i) {
          if (!graphed_set.has(d)) {
            return;
          }
          d.fisheye = fisheye(d);
          if (use_canvas) {
            draw_circle(d.fisheye.x, d.fisheye.y, calc_node_radius(d), d.color || "yellow", d.color || "black");
          }
          if (use_webgl) {
            return mv_node(d.gl, d.fisheye.x, d.fisheye.y);
          }
        });
      }
    };

    should_show_label = function(node) {
      return dist_lt(last_mouse_pos, node, label_show_range) || node.name.match(search_regex) || label_all_graphed_nodes && graphed_set.has(node);
    };

    draw_labels = function() {
      if (use_svg) {
        label.attr("style", function(d) {
          if (should_show_label(d)) {
            return "";
          } else {
            return "display:none";
          }
        });
      }
      if (use_canvas || use_webgl) {
        return nodes.forEach(function(node) {
          if (!should_show_label(node)) {
            return;
          }
          if (node.focused_node) {
            ctx.fillStyle = node.color;
            ctx.font = "9px sans-serif";
          } else {
            ctx.fillStyle = "black";
            ctx.font = "7px sans-serif";
          }
          if (!graphed_set.has(node) && draw_lariat_labels_rotated) {
            ctx.save();
            ctx.translate(node.fisheye.x, node.fisheye.y);
            ctx.rotate(-1 * node.rad + Math.PI / 2);
            ctx.fillText(node.name, 0, 0);
            return ctx.restore();
          } else {
            return ctx.fillText(node.name, node.fisheye.x, node.fisheye.y);
          }
        });
      }
    };

    clear_canvas = function() {
      return ctx.clearRect(0, 0, canvas.width, canvas.height);
    };

    blank_screen = function() {
      if (use_canvas || use_webgl) {
        return clear_canvas();
      }
    };

    tick = function() {
      blank_screen();
      draw_dropzones();
      find_focused_node();
      fisheye.focus(last_mouse_pos);
      position_nodes();
      draw_edges();
      draw_nodes();
      draw_lariat();
      draw_discards();
      draw_labels();
      return update_status();
    };

    update_status = function() {
      var msg;
      msg = "linked:" + nodes.length + " unlinked:" + unlinked_set.length + " links:" + links_set.length + " discarded:" + discarded_set.length + " subjects:" + G.num_subj + " chosen:" + chosen_set.length;
      if (dragging) {
        msg += " DRAG";
      }
      return set_status(msg);
    };

    svg_restart = function() {
      var label, nodeEnter;
      link = link.data(links_set);
      link.enter().insert("line", ".node").attr("class", function(d) {
        return "link";
      });
      link.exit().remove();
      node = node.data(nodes);
      node.exit().remove();
      nodeEnter = node.enter().append("g").attr("class", "lariat node").call(force.drag);
      nodeEnter.append("circle").attr("r", calc_node_radius).style("fill", function(d) {
        return d.color;
      });
      nodeEnter.append("text").attr("class", "label").attr("style", "").attr("dy", ".35em").attr("dx", ".4em").text(function(d) {
        return d.name;
      });
      return label = svg.selectAll(".label");
    };

    canvas_show_text = function(txt, x, y) {
      console.log("canvas_show_text(" + txt + ")");
      ctx.fillStyle = "black";
      ctx.font = "12px Courier";
      return ctx.fillText(txt, x, y);
    };

    pnt2str = function(x, y) {
      return "[" + Math.floor(x) + ", " + Math.floor(y) + "]";
    };

    show_pos = function(x, y, dx, dy) {
      dx = dx || 0;
      dy = dy || 0;
      return canvas_show_text(pnt2str(x, y), x + dx, y + dy);
    };

    show_line = function(x0, y0, x1, y1, dx, dy, label) {
      dx = dx || 0;
      dy = dy || 0;
      label = typeof label === "undefined" && "" || label;
      return canvas_show_text(pnt2str(x0, y0) + "-->" + pnt2str(x0, y0) + " " + label, x1 + dx, y1 + dy);
    };

    add_webgl_line = function(e) {
      return e.gl = add_line(scene, e.source.x, e.source.y, e.target.x, e.target.y, e.source.s.id + " - " + e.target.s.id, "green");
    };

    webgl_restart = function() {
      return links_set.forEach(function(d) {
        return add_webgl_line(d);
      });
    };

    restart = function() {
      if (use_svg) {
        svg_restart();
      }
      return force.start();
    };

    show_last_mouse_pos = function() {
      return draw_circle(last_mouse_pos[0], last_mouse_pos[1], focus_radius, "yellow");
    };

    remove_ghosts = function(e) {
      if (use_webgl) {
        if (e.gl) {
          remove_gl_obj(e.gl);
        }
        return delete e.gl;
      }
    };

    add_node_ghosts = function(d) {
      if (use_webgl) {
        return d.gl = add_node(scene, d.x, d.y, 3, d.color);
      }
    };

    make_edge = function(s, t, c) {
      return {
        source: s,
        target: t,
        color: c || "lightgrey",
        id: s.id + " " + t.id
      };
    };

    load_file = function() {
      var data_uri;
      reset_graph();
      data_uri = $("select#file_picker option:selected").val();
      set_status(data_uri);
      G = {};
      if (!G.subjects) {
        fetchAndShow(data_uri);
      }
      if (use_webgl) {
        return init_webgl();
      }
    };

    add_to_array = function(itm, array, cmp) {
      var c;
      cmp = cmp || array.__current_sort_order || cmp_on_id;
      c = binary_search_on(array, itm, cmp, true);
      if (typeof c === typeof 3) {
        return c;
      }
      array.splice(c.idx, 0, itm);
      return c.idx;
    };

    remove_from_array = function(itm, array, cmp) {
      var c;
      cmp = cmp || array.__current_sort_order || cmp_on_id;
      c = binary_search_on(array, itm, cmp);
      if (c > -1) {
        array.splice(c, 1);
      }
      return array;
    };

    add_to = function(itm, set) {
      var found;
      if (isArray(set)) {
        return add_to_array(itm, set, cmp_on_id);
      }
      if (typeof itm.id === "undefined") {
        throw "add_to() requires itm to have an .id";
      }
      found = set[itm.id];
      if (!found) {
        set[itm.id] = itm;
      }
      return set[itm.id];
    };

    remove_from = function(doomed, set) {
      if (typeof doomed.id === "undefined") {
        throw "remove_from() requires doomed to have an .id";
      }
      if (isArray(set)) {
        return remove_from_array(doomed, set);
      }
      if (set[doomed.id]) {
        delete set[doomed.id];
      }
      return set;
    };

    parseAndShow = function(data, textStatus) {
      var msg, parse_end_time, parse_start_time, parse_time, show_end_time, show_start_time, show_time, siz;
      set_status("parsing");
      msg = "data was " + data.length + " bytes";
      parse_start_time = new Date();
      G = GreenerTurtle(GreenTurtle).parse(data, "text/turtle");
      parse_end_time = new Date();
      parse_time = (parse_end_time - parse_start_time) / 1000;
      siz = roughSizeOfObject(G);
      msg += " resulting in a graph of " + siz + " bytes";
      msg += " which took " + parse_time + " seconds to parse";
      if (verbosity >= COARSE) {
        console.log(msg);
      }
      show_start_time = new Date();
      showGraph(G);
      show_end_time = new Date();
      show_time = (show_end_time - show_start_time) / 1000;
      msg += " and " + show_time + " sec to show";
      if (verbosity >= COARSE) {
        console.log(msg);
      }
      $("body").css("cursor", "default");
      return $("#status").text("");
    };

    fetchAndShow = function(url) {
      $("#status").text("fetching " + url);
      $("body").css("cursor", "wait");
      return $.ajax({
        url: url,
        success: parseAndShow,
        error: function(jqxhr, textStatus, errorThrown) {
          return $("#status").text(errorThrown + " while fetching " + url);
        }
      });
    };

    has_predicate_value = function(subject, predicate, value) {
      var obj, objs, oi, pre;
      pre = subject.predicates[predicate];
      if (pre) {
        objs = pre.objects;
        oi = 0;
        while (oi <= objs.length) {
          obj = objs[oi];
          if (obj.value === value) {
            return true;
          }
          oi++;
        }
      }
      return false;
    };

    FOAF_Group = "http://xmlns.com/foaf/0.1/Group";

    FOAF_name = "http://xmlns.com/foaf/0.1/name";

    RDF_Type = "http://www.w3.org/1999/02/22-rdf-syntax-ns#type";

    RDF_object = "http://www.w3.org/1999/02/22-rdf-syntax-ns#object";

    has_type = function(subject, typ) {
      return has_predicate_value(subject, RDF_Type, typ);
    };

    is_a_main_node = function(d) {
      return (BLANK_HACK && d.s.id[7] !== "/") || (!BLANK_HACK && d.s.id[0] !== "_");
    };

    is_node_to_always_show = is_a_main_node;

    show_and_hide_links_from_node = function(d) {
      show_links_from_node(d);
      return hide_links_from_node(d);
    };

    get_window_width = function(pad) {
      pad = pad || hpad;
      width = (window.innerWidth || document.documentElement.clientWidth || document.clientWidth) - pad;
      return cx = width / 2;
    };

    get_window_height = function(pad) {
      pad = pad || hpad;
      height = (window.innerHeight || document.documentElement.clientHeight || document.clientHeight) - pad;
      return cy = height / 2;
    };

    update_graph_radius = function() {
      return graph_radius = Math.floor(Math.min(width / 2, height / 2)) * .9;
    };

    update_lariat_zone = function() {
      return lariat_center = [width / 2, height / 2];
    };

    update_discard_zone = function() {
      var discard_ratio;
      discard_ratio = .1;
      discard_radius = graph_radius * discard_ratio;
      return discard_center = [width - discard_radius * 3, height - discard_radius * 3];
    };

    fisheye = d3.fisheye.circular().radius(fisheye_radius).distortion(fisheye_zoom);

    fill = d3.scale.category20();

    force = d3.layout.force().size([width, height]).nodes([]).linkDistance(link_distance).charge(get_charge).gravity(gravity).on("tick", tick);

    svg = d3.select("#vis").append("svg").attr("width", width).attr("height", height).attr("position", "absolute");

    svg.append("rect").attr("width", width).attr("height", height);

    viscanvas = d3.select("#viscanvas").append("canvas").attr("width", width).attr("height", height);

    canvas = viscanvas[0][0];

    mouse_receiver = viscanvas;

    mouse_receiver.on("mousemove", mousemove).on("mousedown", mousedown).on("mouseup", mouseup).on("mouseout", mouseup);

    updateWindow();

    ctx = canvas.getContext("2d");

    reset_graph();

    cursor = svg.append("circle").attr("r", label_show_range).attr("transform", "translate(" + cx + "," + cy + ")").attr("class", "cursor");

    restart();

    set_search_regex = function(text) {
      return search_regex = new RegExp(text || "^$", "ig");
    };

    update_searchterm = function() {
      var text;
      text = $(this).text();
      set_search_regex(text);
      return restart();
    };

    set_search_regex("");

    $(".search_box").on("input", update_searchterm);

    node_radius_policies = {
      "node radius by links": function(d) {
        d.radius = Math.max(little_dot, Math.log(d.links_shown.length));
        return d.radius;
        if (d.showing_links === "none") {
          d.radius = little_dot;
        } else {
          if (d.showing_links === "all") {
            d.radius = Math.max(little_dot, 2 + Math.log(d.links_shown.length));
          }
        }
        return d.radius;
      },
      "equal dots": function(d) {
        return little_dot;
      }
    };

    default_node_radius_policy = "equal dots";

    default_node_radius_policy = "node radius by links";

    node_radius_policy = node_radius_policies[default_node_radius_policy];

    dump_locations = function(srch, verbose, func) {
      var pattern;
      verbose = verbose || false;
      pattern = new RegExp(srch, "ig");
      return nodes.forEach(function(node, i) {
        if (!node.name.match(pattern)) {
          if (verbose) {
            console.log(pattern, "does not match", node.name);
          }
          return;
        }
        if (func) {
          console.log(func.call(node));
        }
        if (!func || verbose) {
          return dump_details(node);
        }
      });
    };

    get_node_by_id = function(node_id, throw_on_fail) {
      var idx;
      throw_on_fail = throw_on_fail || false;
      idx = binary_search_on(nodes, {
        id: node_id
      });
      if (idx > -1) {
        return nodes[idx];
      } else {
        if (throw_on_fail) {
          throw "node with id <" + node_id + "> not found";
        } else {

        }
      }
    };

    update_flags = function(n) {
      var old_linked_status;
      old_linked_status = graphed_set.has(n);
      if (old_linked_status) {
        if (!n.links_from_found || !n.links_to_found) {
          return n.showing_links = "some";
        } else {
          if (n.links_from.length + n.links_to.length > n.links_shown.length) {
            return n.showing_links = "some";
          } else {
            return n.showing_links = "all";
          }
        }
      } else {
        return n.showing_links = "none";
      }
    };

    add_link = function(e) {
      links_set.add(e);
      add_to(e, e.source.links_from);
      add_to(e, e.source.links_shown);
      add_to(e, e.target.links_to);
      add_to(e, e.target.links_shown);
      update_flags(e.source);
      update_flags(e.target);
      return restart();
    };

    UNDEFINED = void 0;

    remove_link = function(e) {
      if (links_set.indexOf(e) === -1) {
        return;
      }
      remove_from(e, e.source.links_shown);
      remove_from(e, e.target.links_shown);
      links_set.remove(e);
      update_flags(e.source);
      return update_flags(e.target);
    };

    find_links_from_node = function(node) {
      var obj, oi, p_name, pnt, predicate, subj, target, x, y;
      target = void 0;
      subj = node.s;
      x = node.x || width / 2;
      y = node.y || height / 2;
      pnt = [x, y];
      oi = void 0;
      if (subj) {
        for (p_name in subj.predicates) {
          ensure_predicate(p_name);
          predicate = subj.predicates[p_name];
          oi = 0;
          while (oi < predicate.objects.length) {
            obj = predicate.objects[oi];
            if (obj.type === RDF_object) {
              target = get_or_make_node(G.subjects[obj.value], pnt);
            }
            if (!target) {
              continue;
            }
            add_link(make_edge(node, target));
            oi++;
          }
        }
      }
      return node.links_from_found = true;
    };

    find_links_to_node = function(d) {
      var parent_point, subj;
      subj = d.s;
      if (subj) {
        parent_point = [d.x, d.y];
        G.get_incoming_predicates(subj).forEach(function(sid_pred) {
          var pred, sid, src;
          sid = sid_pred[0];
          pred = sid_pred[1];
          src = get_or_make_node(G.subjects[sid], parent_point);
          return add_link(make_edge(src, d));
        });
      }
      return d.links_to_found = true;
    };

    show_link = function(edge, incl_discards) {
      if ((!incl_discards) && (edge.target.state === discarded_set || edge.source.state === discarded_set)) {
        return;
      }
      add_to(edge, edge.source.links_shown);
      add_to(edge, edge.target.links_shown);
      links_set.add(edge);
      update_state(edge.source);
      return update_state(edge.target);
    };

    show_links_to_node = function(n, incl_discards) {
      incl_discards = incl_discards || false;
      if (!n.links_to_found) {
        find_links_to_node(n);
      }
      n.links_to.forEach(function(e, i) {
        return show_link(e, incl_discards);
      });
      force.links(links_set);
      return restart();
    };

    update_state = function(node) {
      if (node.links_shown.length === 0) {
        return unlinked_set.acquire(node);
      } else {
        return graphed_set.acquire(node);
      }
    };

    hide_links_to_node = function(n) {
      n.links_to.forEach(function(e, i) {
        remove_from(e, n.links_shown);
        remove_from(e, e.source.links_shown);
        links_set.remove(e);
        remove_ghosts(e);
        update_state(e.source);
        update_flags(e.source);
        return update_flags(e.target);
      });
      update_state(n);
      force.links(links_set);
      return restart();
    };

    show_links_from_node = function(n, incl_discards) {
      var subj;
      incl_discards = incl_discards || false;
      subj = n.s;
      if (!n.links_from_found) {
        find_links_from_node(n);
      } else {
        n.links_from.forEach(function(e, i) {
          return show_link(e, incl_discards);
        });
      }
      update_state(n);
      force.links(links_set);
      return restart();
    };

    hide_links_from_node = function(n) {
      n.links_from.forEach(function(e, i) {
        remove_from(e, n.links_shown);
        remove_from(e, e.target.links_shown);
        links_set.remove(e);
        remove_ghosts(e);
        update_state(e.target);
        update_flags(e.source);
        return update_flags(e.target);
      });
      force.links(links_set);
      return restart();
    };

    get_or_make_node = function(subject, start_point, linked) {
      var d, n_idx, name;
      if (!subject) {
        return;
      }
      d = get_node_by_id(subject.id);
      if (d) {
        return d;
      }
      start_point = start_point || [width / 2, height / 2];
      linked = typeof linked === "undefined" || linked || false;
      name = subject.predicates[FOAF_name].objects[0].value;
      d = {
        x: start_point[0],
        y: start_point[1],
        px: start_point[0] * 1.01,
        py: start_point[1] * 1.01,
        linked: false,
        links_shown: [],
        links_from: [],
        links_from_found: false,
        links_to: [],
        links_to_found: false,
        showing_links: "none",
        name: name,
        s: subject
      };
      d.color = color_by_type(d);
      d.id = d.s.id;
      add_node_ghosts(d);
      n_idx = add_to_array(d, nodes);
      id2n[subject.id] = n_idx;
      if (!linked) {
        n_idx = unlinked_set.acquire(d);
        id2u[subject.id] = n_idx;
      } else {
        id2u[subject.id] = graphed_set.acquire(d);
      }
      update_flags(d);
      return d;
    };

    make_nodes = function(g, limit) {
      var count, subj, subject, _results;
      limit = limit || 0;
      count = 0;
      _results = [];
      for (subj in g.subjects) {
        if (verbosity >= DEBUG) {
          console.log(subj, g.subjects[subj]);
        }
        if (!subj.match(ids_to_show)) {
          continue;
        }
        subject = g.subjects[subj];
        get_or_make_node(subject, [width / 2, height / 2], false);
        count++;
        if (limit && count >= limit) {
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    make_links = function(g, limit) {
      limit = limit || 0;
      console.log("make_links");
      nodes.some(function(node, i) {
        var subj;
        subj = node.s;
        show_links_from_node(nodes[i]);
        if ((limit > 0) && (links_set.length >= limit)) {
          return true;
        }
      });
      console.log("/make_links");
      return restart();
    };

    hide_node_links = function(node) {
      console.log("hide_node_links(" + node.id + ")");
      node.links_shown.forEach(function(e, i) {
        console.log("  ", e.id);
        links_set.remove(e);
        if (e.target === node) {
          remove_from(e, e.source.links_shown);
          update_state(e.source);
          update_flags(e.source);
        } else {
          remove_from(e, e.target.links_shown);
          update_state(e.target);
          update_flags(e.target);
        }
        return remove_ghosts(e);
      });
      node.links_shown = [];
      update_state(node);
      return update_flags(node);
    };

    hide_found_links = function() {
      nodes.forEach(function(node, i) {
        if (node.name.match(search_regex)) {
          return hide_node_links(node);
        }
      });
      return restart();
    };

    discard_found_nodes = function() {
      nodes.forEach(function(node, i) {
        if (node.name.match(search_regex)) {
          return discard(node);
        }
      });
      return restart();
    };

    show_node_links = function(node) {
      show_links_from_node(node);
      show_links_to_node(node);
      return update_flags(node);
    };

    show_found_links = function() {
      var sub_id, subj;
      for (sub_id in G.subjects) {
        subj = G.subjects[sub_id];
        subj.getValues("f:name").forEach(function(name) {
          if (name.match(search_regex)) {
            node = get_or_make_node(subj, [cx, cy]);
            if (node) {
              return show_node_links(node);
            }
          }
        });
      }
      return restart();
    };

    toggle_links = function() {
      if (!links_set.length) {
        make_links(G);
        restart();
      }
      return force.links().length;
    };

    toggle_label_display = function() {
      label_all_graphed_nodes = !label_all_graphed_nodes;
      return tick();
    };

    hide_all_links = function() {
      nodes.forEach(function(node) {
        unlinked_set.acquire(node);
        node.links_shown = [];
        node.showing_links = "none";
        unlinked_set.acquire(node);
        return update_flags(node);
      });
      links_set.forEach(function(link) {
        return remove_ghosts(link);
      });
      links_set.clear();
      chosen_set.clear();
      return restart();
    };

    set_status = function(txt) {
      txt = txt || "";
      if (last_status !== txt) {
        console.log(txt);
        $("#status").text(txt);
      }
      return last_status = txt;
    };

    toggle_display_tech = function(ctrl, tech) {
      var val;
      val = void 0;
      tech = ctrl.parentNode.id;
      if (tech === "use_canvas") {
        use_canvas = !use_canvas;
        if (!use_canvas) {
          clear_canvas();
        }
        val = use_canvas;
      }
      if (tech === "use_svg") {
        use_svg = !use_svg;
        val = use_svg;
      }
      if (tech === "use_webgl") {
        use_webgl = !use_webgl;
        val = use_webgl;
      }
      ctrl.checked = val;
      tick();
      return true;
    };

    unlink = function(unlinkee) {
      hide_links_from_node(unlinkee);
      hide_links_to_node(unlinkee);
      unlinked_set.acquire(unlinkee);
      return update_flags(unlinkee);
    };

    discard = function(goner) {
      unchoose(goner);
      unlink(goner);
      discarded_set.acquire(goner);
      return update_flags(goner);
    };

    undiscard = function(prodigal) {
      unlinked_set.acquire(prodigal);
      return update_flags(prodigal);
    };

    unchoose = function(goner) {
      chosen_set.remove(goner);
      hide_node_links(goner);
      unlinked_set.acquire(goner);
      return update_flags(goner);
    };

    choose = function(chosen) {
      chosen_set.add(chosen);
      show_links_from_node(chosen);
      show_links_to_node(chosen);
      if (chosen.links_shown) {
        graphed_set.acquire(chosen);
        chosen.showing_links = "all";
      } else {
        unlinked_set.acquire(chosen);
      }
      update_state(chosen);
      return update_flags(chosen);
    };

    update_history = function() {
      var hash, n_chosen, the_state, the_title, the_url;
      if (history.pushState) {
        the_state = {};
        hash = "";
        if (chosen_set.length) {
          the_state.chosen_node_ids = [];
          hash += "#";
          hash += "chosen=";
          n_chosen = chosen_set.length;
          chosen_set.forEach(function(chosen, i) {
            hash += chosen.id;
            the_state.chosen_node_ids.push(chosen.id);
            if (n_chosen > i + 1) {
              return hash += ",";
            }
          });
        }
        the_url = location.href.replace(location.hash, "") + hash;
        the_title = document.title;
        return history.pushState(the_state, the_title, the_state);
      }
    };

    restore_graph_state = function(state) {
      if (!state) {
        return;
      }
      if (state.chosen_node_ids) {
        reset_graph();
        return state.chosen_node_ids.forEach(function(chosen_id) {
          var chosen;
          chosen = get_or_make_node(chosen_id);
          if (chosen) {
            return choose(chosen);
          }
        });
      }
    };

    showGraph = function(g) {
      console.log("showGraph");
      make_nodes(g);
      return restart();
    };

    wait_for_GreenTurtle = function() {
      if (typeof GreenTurtle === "undefined") {
        return setTimeout(wait_for_GreenTurtle, 200);
      } else {
        return load_file();
      }
    };

    await_the_GreenTurtle = function() {
      var error, i;
      try {
        i = GreenTurtle.implementation;
        return load_file();
      } catch (_error) {
        error = _error;
        console.log(error);
        return setTimeout(await_the_GreenTurtle, 3000);
      }
    };

    window.addEventListener("load", function() {
      console.log("load_file() via 'load' listener");
      return load_file();
    });

    window.addEventListener("popstate", function(event) {
      return restore_graph_state(event.state);
    });

    window.addEventListener("resize", updateWindow);

    edge_controller = new require("crrt").CollapsibleRadialReingoldTilfordTree();

    alert(edge_controller.show_tree_in(predicates, 'edgectrl'));

    return Huviz;

  })();

}).call(this);
